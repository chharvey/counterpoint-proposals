# Semantics Discussion

## Keyword `void` Must Be Isolated
Continued from #96. The keyword `void` is not a type and cannot be treated as types in the type system. It may only be used in return signatures of functions that execute completely but that do not return a value. It may not be combined with types. Functions can only return a type, or return void, but not a combination.
```cpl
func return_void(): void { % ok
	print.("hello");
	return;
}

func return_int_or_void(): int | void %> SyntaxError
	=> 42;

type VoidFn = \() => void; % ok
type VoidOrIntFn = \() => int | void; %> SyntaxError

func return_int(): int {
	return; %> AssignmentError
}

class abstract Foo {
	public doSomething(): void; % ok

	public callVoidFn(void_fn: \() => void): void { % ok
		return void_fn.();
	}
}
```

## Void Function Returns
Void function bodies are now required to have an explicit `return;` statement in every code path. This cannot be enforced syntactically, because it requires control flow analysis.
```cpl
func maybe_return_void(): void {
	print.("hello");
	return; % <- required statement
}

func return_void(): void {
	print.("hello");
	return; % <- required statement
}
func conditionally_return_void(b: bool): void {
	if b then {
		print.(b);
		return; % <- required statement
	} else {
		print.("""not {{ !b }}""");
		return; % <- required statement
	};
}
func no_else_branch(b: bool): void {
	if b then {
		print.(b);
	};
	return; % <- also valid
}
func invalid_no_else_branch(b: bool): void {
	if b then {
		print.(b);
		return;
	};
	%> SemanticError: Expected a `return` statment in all code paths.
}
```

## Void Function Calls
Disallow assignment and operations of void function calls in most cases.
```cpl
func return_void(): void {
	print.("hello");
	return;
}
let val: anything = return_void.(); %> TypeError

return_void.() || 42;   %> TypeError
true && return_void.(); %> TypeError

func take_anything(arg: anything): 0 {
	arg;
	return 0;
}
take_anything.(return_void.()); %> TypeError

func return_anything(): anything {
	return return_void.(); %> TypeError
}

let tup:     (anything,)   = (return_void.(),); %> TypeError
let tup_opt: (?: anything) = (return_void.(),); %> TypeError
List.<anything>().append.(return_void.());      %> TypeError
```

**There is one exception:** A void function call may be *returned* from another void function. This allows us to utilize tail calls.
```cpl
func print_hello(): void {
	return print.("hello"); % tail call allowed here
}

func print_world(): void
	=> print.("world"); % implicit returns also allowed
```
The code above is valid, but only because the return signatures of the calling function and the called function are both `void`. If either function had a different return signature, we could not use the tail call.

With tail call optimization, the stack frame of the calling function may be reused to execute the called function. If returning void function calls were not allowed, we could not utilize this optimization.
```cpl
func countdown(n: int): void {
	if n > 0 then {
		print.(n);
		countdown.(n - 1);
		return;
	} else {
		print.("Blast off!");
		return;
	};
}
```
The code above is valid, but not optimal. Because this particular function is recursive, a tail call `return countdown.(n - 1);` would optimize the call stack and improve performance significantly.

Tail calls also allow us to write more functional-style code. Void functions should not have a disadvantage when writing in this style.
```point
% signature of `List<T>#forEach`: `\(List.<T>; callback: (T) => void) => void`

List.<int>(my_ints).forEach.(\(i) => print.(i));

% is better than:

List.<int>(my_ints).forEach.(\(i) {
	print.(i);
	return;
});
```
