The **default default value** of an optional parameter is `null`.

When an optional parameter is specified, it was required to be given a default value.
```cp
function moveForward(steps: int ?= 1): void {
%                                  ^ default value
	print.(steps);
}
moveForward.();  % prints "1"
moveForward.(2); % prints "2"
```

Now that requirement is relaxed. If not provided, the default value *defaults* to `null`.
```cp
function moveForward(steps?: int | null): void {
%                         ^ new token, shorthand for `steps: int | null ?= null`
	print.(steps);
}
moveForward.();  % prints "null"
moveForward.(2); % prints "2"
```
The symbol for an optional parameter annotation is `?:`, as it is for tuples and records with optional entries.
```cp
type NumberPairT = [int, ?: float];
type NumberPairR = [a: int, b?: float];
```
This symbol is only for the implicit default. For optional parameters with explicit default values, the colon is still used.
```cp
function moveForward(steps: int ?= 1): void {
%                         ^ stays the same
	print.(steps);
}
```

Because the “default default value” is `null`, the type of the optional parameter must include `null`.
```cp
function moveForward(steps?: int): void { %> TypeError: `null` is not a subtype of `int`.
	print.(steps);
}
```

As always, the shorthand for a type union with `null` is the postfix unary type operator `?`.
```cp
function moveForward(steps?: int?): void {
%                            ^ int | null
	print.(steps);
}
```

# Specification

## Syntax
```diff
ParameterFunction<Optional>
-	::= (IDENTIFIER "=")? "var"? IDENTIFIER               ":" Type . <Optional+>(                     "?=" Expression);
+	::= (IDENTIFIER "=")? "var"? IDENTIFIER . <Optional->(":" Type)  <Optional+>("?:" Type | ":" Type "?=" Expression);
```

## Semantics
```diff
SemanticParameterType[optional: Boolean]
	::= SemanticVariable? SemanticType;

-SemanticParameter[unfixed: Boolean]
-	::= SemanticKey? SemanticVariable SemanticType SemanticExpression?;
+SemanticParameter[optional: false][unfixed: Boolean]
+	::= SemanticKey? SemanticVariable SemanticType;
+SemanticParameter[optional: true][unfixed: Boolean]
+	::= SemanticKey? SemanticVariable SemanticType SemanticExpression?;
```

## Decorate
```diff
-Decorate(ParameterFunction            ::= IDENTIFIER ":" Type) -> SemanticParameter
+Decorate(ParameterFunction<-Optional> ::= IDENTIFIER ":" Type) -> SemanticParameter
-	:= (SemanticParameter[unfixed=false]
+	:= (SemanticParameter[optional=false][unfixed=false]
		(SemanticVariable[id=TokenWorth(IDENTIFIER)])
		Decorate(Type)
	);
-Decorate(ParameterFunction            ::= "var" IDENTIFIER ":" Type) -> SemanticParameter
+Decorate(ParameterFunction<-Optional> ::= "var" IDENTIFIER ":" Type) -> SemanticParameter
-	:= (SemanticParameter[unfixed=true]
+	:= (SemanticParameter[optional=false][unfixed=true]
		(SemanticVariable[id=TokenWorth(IDENTIFIER)])
		Decorate(Type)
	);
-Decorate(ParameterFunction            ::= IDENTIFIER__0 "=" IDENTIFIER__1 ":" Type) -> SemanticParameter
+Decorate(ParameterFunction<-Optional> ::= IDENTIFIER__0 "=" IDENTIFIER__1 ":" Type) -> SemanticParameter
-	:= (SemanticParameter[unfixed=false]
+	:= (SemanticParameter[optional=false][unfixed=false]
		(SemanticKey[id=TokenWorth(IDENTIFIER__0)])
		(SemanticVariable[id=TokenWorth(IDENTIFIER__1)])
		Decorate(Type)
	);
-Decorate(ParameterFunction            ::= IDENTIFIER__0 "=" "var" IDENTIFIER__1 ":" Type) -> SemanticParameter
+Decorate(ParameterFunction<-Optional> ::= IDENTIFIER__0 "=" "var" IDENTIFIER__1 ":" Type) -> SemanticParameter
-	:= (SemanticParameter[unfixed=true]
+	:= (SemanticParameter[optional=false][unfixed=true]
		(SemanticKey[id=TokenWorth(IDENTIFIER__0)])
		(SemanticVariable[id=TokenWorth(IDENTIFIER__1)])
		Decorate(Type)
	);

+Decorate(ParameterFunction<+Optional> ::= IDENTIFIER "?:" Type) -> SemanticParameter
+	:= (SemanticParameter[optional=true][unfixed=false]
+		(SemanticVariable[id=TokenWorth(IDENTIFIER)])
+		Decorate(Type)
+		(SemanticConstant[value=null])
+	);
Decorate(ParameterFunction<+Optional> ::= IDENTIFIER ":" Type "?=" Expression) -> SemanticParameter
-	:= (SemanticParameter[unfixed=false]
+	:= (SemanticParameter[optional=true][unfixed=false]
		(SemanticVariable[id=TokenWorth(IDENTIFIER)])
		Decorate(Type)
		Decorate(Expression)
	);
+Decorate(ParameterFunction<+Optional> ::= "var" IDENTIFIER "?:" Type) -> SemanticParameter
+	:= (SemanticParameter[optional=true][unfixed=true]
+		(SemanticVariable[id=TokenWorth(IDENTIFIER)])
+		Decorate(Type)
+		(SemanticConstant[value=null])
+	);
Decorate(ParameterFunction<+Optional> ::= "var" IDENTIFIER ":" Type "?=" Expression) -> SemanticParameter
-	:= (SemanticParameter[unfixed=true]
+	:= (SemanticParameter[optional=true][unfixed=true]
		(SemanticVariable[id=TokenWorth(IDENTIFIER)])
		Decorate(Type)
		Decorate(Expression)
	);
+Decorate(ParameterFunction<+Optional> ::= IDENTIFIER__0 "=" IDENTIFIER__1 "?:" Type) -> SemanticParameter
+	:= (SemanticParameter[optional=true][unfixed=false]
+		(SemanticKey[id=TokenWorth(IDENTIFIER__0)])
+		(SemanticVariable[id=TokenWorth(IDENTIFIER__1)])
+		Decorate(Type)
+		(SemanticConstant[value=null])
+	);
Decorate(ParameterFunction<+Optional> ::= IDENTIFIER__0 "=" IDENTIFIER__1 ":" Type "?=" Expression) -> SemanticParameter
-	:= (SemanticParameter[unfixed=false]
+	:= (SemanticParameter[optional=true][unfixed=false]
		(SemanticKey[id=TokenWorth(IDENTIFIER__0)])
		(SemanticVariable[id=TokenWorth(IDENTIFIER__1)])
		Decorate(Type)
		Decorate(Expression)
	);
+Decorate(ParameterFunction<+Optional> ::= IDENTIFIER__0 "=" "var" IDENTIFIER__1 "?:" Type) -> SemanticParameter
+	:= (SemanticParameter[optional=true][unfixed=true]
+		(SemanticKey[id=TokenWorth(IDENTIFIER__0)])
+		(SemanticVariable[id=TokenWorth(IDENTIFIER__1)])
+		Decorate(Type)
+		(SemanticConstant[value=null])
+	);
Decorate(ParameterFunction<+Optional> ::= IDENTIFIER__0 "=" "var" IDENTIFIER__1 ":" Type "?=" Expression) -> SemanticParameter
-	:= (SemanticParameter[unfixed=true]
+	:= (SemanticParameter[optional=true][unfixed=true]
		(SemanticKey[id=TokenWorth(IDENTIFIER__0)])
		(SemanticVariable[id=TokenWorth(IDENTIFIER__1)])
		Decorate(Type)
		Decorate(Expression)
	);
```
